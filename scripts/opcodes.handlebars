// -- 
// -- DO NOT EDIT THIS FILE
// -- This file is generated by scripts/opcodes.js --
// --   at {{now}} --
// 
// -- If you want to edit this, go to {repo}/scripts - folder, 
// --   and run `npm run start`.
// -- The new file will be generated in {repo}/scripts/generated - folder
// -- The code is generated from {{templateFileName}} with {{csvDataFileName}}
// --

use std::{collections::HashMap, fmt};

#[derive(Debug, PartialEq, Eq, Hash)]
pub enum Opcode {
    {{#each opcodes_enum}}
    {{this}},
    {{/each}}
}

#[derive(Debug, Clone)]
pub struct AluControlBits {
    pub zx: bool,
    pub nx: bool,
    pub zy: bool,
    pub ny: bool,
    pub f: bool,
    pub no: bool,
    pub int: String,
    pub hex: String,
    pub bin: String,
    pub name: String,
}

impl fmt::Display for AluControlBits {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "name: {}, int: {}, hex: {}, bin: {}, 
            bytes: (zx:{}, nx:{}, zy:{}, ny:{}, f:{}, no: {})",
            self.name,
            self.int,
            self.hex,
            self.bin,
            self.zx,
            self.nx,
            self.zy,
            self.ny,
            self.f,
            self.no
        )
    }
}

pub fn get_opcodes() -> HashMap<Opcode, AluControlBits> {
    let mut opcodes = HashMap::new();

    {{#each opcodes_hasmap_inserts}}
    opcodes.insert(
        Opcode::{{currentOpCodeEnum}},
        AluControlBits {
            zx: {{zx}},
            nx: {{nx}},
            zy: {{zy}},
            ny: {{ny}},
            f: {{f}},
            no: {{no}},
            name: String::from("{{name}}"),
            int:  String::from("{{int}}"),
            hex:  String::from("{{hex}}"),
            bin:  String::from("{{bin}}"),
        },
    );
    {{/each}}

    opcodes
}
